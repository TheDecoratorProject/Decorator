using Decorator.Attributes;
using Decorator.Exceptions;

using System.Collections.Generic;
using System.Linq;

namespace Decorator {

	/// <summary>Serialize a <see cref="TClass" /> to a <see cref="BaseMessage" /></summary>
	public static class Serializer {

		/// <summary>Serializes the specified item.</summary>
		/// <typeparam name="TClass">The type of the class.</typeparam>
		/// <param name="itm">The item.</param>
		/// <returns></returns>
		/// <autogeneratedoc />
		public static BaseMessage SerializeItem<TClass>(TClass itm)
			where TClass : class {
			var def = MessageManager.GetDefinitionFor<TClass>();

			if (def is null) throw new MissingAttributeException(typeof(MessageAttribute), typeof(TClass));

			var data = new object[def.MaxCount];

			foreach (var i in def.Properties)
				data[(int)i.Position] = i.Get(itm);

			return new BasicMessage(def.Type, data);
		}

		/// <summary>Serializes the items specified.</summary>
		/// <typeparam name="TClass">The type of the class.</typeparam>
		/// <param name="items">The items.</param>
		/// <returns></returns>
		/// <autogeneratedoc />
		public static BaseMessage SerializeItems<TClass>(IEnumerable<TClass> items)
			where TClass : class {
			var def = MessageManager.GetDefinitionFor<TClass>();

			var itms = items.ToArray();

			var objs = new object[itms.Length * def.MaxCount];

			if (objs.Length == 0) return new BasicMessage(def.Type);

			for (var i = 0; i < itms.Length; i++)
				foreach (var j in def.Properties)
					objs[(i * def.MaxCount) + (int)j.Position] = j.Get(itms[i]);

			return new BasicMessage(def.Type, objs);
		}
	}
}